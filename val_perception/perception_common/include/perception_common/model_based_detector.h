//
// Created by will on 5/24/17.
//

#ifndef PROJECT_MODEL_BASED_DETECTOR_H
#define PROJECT_MODEL_BASED_DETECTOR_H

#include <tf/transform_listener.h>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>
#include <geometry_msgs/PoseStamped.h>

/**
 * This is a class to detect the presence and pose of an object based on a point cloud model (such as one generated by
 * running `pcl_mesh_sampling model_in.obj model_out.pcd -write-normals`. Expects input models to have normals. See
 * rover_detection_2_node in val_task2 for an example of usage.
 *
 * Implements the approach described here (with improvements to work around some of PCL's many idiosyncrasies):
 * http://pointclouds.org/documentation/tutorials/alignment_prerejective.php#alignment-prerejective
 */

class model_based_detector {
public:
    // point / point cloud typedefs for convenience
    typedef pcl::PointXYZ                       InputPoint;
    typedef pcl::PointCloud<InputPoint>         InputCloud;
    typedef pcl::PointNormal                    InputNormalPoint;
    typedef pcl::PointCloud<InputNormalPoint>   InputNormalCloud;
    typedef pcl::FPFHSignature33                FeaturePoint;
    typedef pcl::PointCloud<FeaturePoint>       FeatureCloud;

private:
    // Detection model and parameters
    InputCloud::ConstPtr model_;
    float downsample_resolution_ = 0.01;
    bool use_crop_box_ = false;
    Eigen::Vector4f crop_box_min_;
    Eigen::Vector4f crop_box_max_;

    // publishers and subscribers
    tf::TransformListener tf_listener_;
    ros::Subscriber cloud_sub_;
    ros::Publisher debug_points_;
    ros::Publisher env_points_;
    ros::Publisher model_points_;
    ros::Publisher debug_markers_;

    // detection data
    bool detected_;
    geometry_msgs::PoseStamped latest_detection_;

public:
    model_based_detector(ros::NodeHandle nh, const std::string &cloud_topic, InputCloud::ConstPtr model);
    model_based_detector(ros::NodeHandle nh, const std::string &cloud_topic, const std::string &model_path)
            : model_based_detector(nh, cloud_topic, readModelFromPath(model_path)) {}

    static InputCloud::ConstPtr readModelFromPath(const std::string &path);

    void setResolution(const float res);

    void setCrop();
    void setNoCrop();
    void setCrop(const Eigen::Vector4f &max, const Eigen::Vector4f &min);

    void cloudCallback(const InputCloud::ConstPtr &cloud);

    bool getDetection(geometry_msgs::PoseStamped &detection);
    void clearDetection();

    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
private:
    // Util functions
    bool findModelTransformation(const InputCloud::ConstPtr &cloud_in, Eigen::Matrix4f &detection);
    InputNormalCloud::ConstPtr filterModel();
    InputNormalCloud::ConstPtr filterInput(const InputCloud::ConstPtr &cloud_in);
    FeatureCloud::ConstPtr computeFeatures(const InputNormalCloud::ConstPtr &cloud_in);
    geometry_msgs::PointStamped getCurrentViewpoint(const std::string &cloud_frame_name);
};

#endif //PROJECT_MODEL_BASED_DETECTOR_H
